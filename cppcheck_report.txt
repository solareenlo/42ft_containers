main.cpp:323:14: style: Redundant initialization for 'rit'. The initialized value is overwritten before it is read. [redundantInitialization]
    for (rit = v.rbegin(); rit != v.rend(); ++rit) *rit = ++i;
             ^
main.cpp:321:43: note: rit is initialized
    ft::vector<int>::reverse_iterator rit = v.rbegin();
                                          ^
main.cpp:323:14: note: rit is overwritten
    for (rit = v.rbegin(); rit != v.rend(); ++rit) *rit = ++i;
             ^
main.cpp:1143:14: style: Redundant initialization for 'rit'. The initialized value is overwritten before it is read. [redundantInitialization]
    for (rit = dq.rbegin(); rit != dq.rend(); ++rit) {
             ^
main.cpp:1141:42: note: rit is initialized
    ft::deque<int>::reverse_iterator rit = dq.rbegin();
                                         ^
main.cpp:1143:14: note: rit is overwritten
    for (rit = dq.rbegin(); rit != dq.rend(); ++rit) {
             ^
main.cpp:883:39: style: Local variable 'it' shadows outer variable [shadowVariable]
    for (ft::map<char, int>::iterator it = m.begin(); it != m.end(); ++it) {
                                      ^
main.cpp:879:34: note: Shadowed declaration
    ft::map<char, int>::iterator it;
                                 ^
main.cpp:883:39: note: Shadow variable
    for (ft::map<char, int>::iterator it = m.begin(); it != m.end(); ++it) {
                                      ^
main.cpp:888:39: style: Local variable 'it' shadows outer variable [shadowVariable]
    for (ft::map<char, int>::iterator it = m2.begin(); it != m2.end(); ++it) {
                                      ^
main.cpp:879:34: note: Shadowed declaration
    ft::map<char, int>::iterator it;
                                 ^
main.cpp:888:39: note: Shadow variable
    for (ft::map<char, int>::iterator it = m2.begin(); it != m2.end(); ++it) {
                                      ^
main.cpp:357:21: style: Unused variable: first [unusedVariable]
    ft::vector<int> first;
                    ^
main.cpp:744:17: style: Variable 'fourth['b']' is assigned a value that is never used. [unreadVariable]
    fourth['b'] = 30;
                ^
main.cpp:748:16: style: Variable 'fifth['d']' is assigned a value that is never used. [unreadVariable]
    fifth['d'] = 70;
               ^
vector.hpp:332:41: warning:inconclusive: Member variable 'vector < int , std :: allocator < int > >::m_allocator_' is not assigned a value in 'vector < int , std :: allocator < int > >::operator='. [operatorEqVarError]
vector<T, Alloc>& ft::vector<T, Alloc>::operator=(const vector& x) {
                                        ^
map.hpp:85:5: warning:inconclusive: Member variable 'map < int , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > >::m_key_compare_' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    map(const map& x)
    ^
map.hpp:85:5: warning:inconclusive: Member variable 'map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > >::m_key_compare_' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    map(const map& x)
    ^
map.hpp:85:5: warning:inconclusive: Member variable 'map < std :: string , char , ft :: less < Key > , std :: allocator < ft :: pair < const Key , char > > >::m_key_compare_' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    map(const map& x)
    ^
main.cpp:58:10: style:inconclusive: Technically the member function 'Compare::operator()' can be const. [functionConst]
    bool operator()(int a, int b) { return (a == b); }
         ^
vector.hpp:134:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::operator[]' can be const. [functionConst]
    reference       operator[](size_type n) { return *(m_begin_ + n); }
                    ^
vector.hpp:137:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::at' can be const. [functionConst]
    reference       at(size_type n) {
                    ^
vector.hpp:150:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::front' can be const. [functionConst]
    reference       front() { return *m_begin_; }
                    ^
vector.hpp:153:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::back' can be const. [functionConst]
    reference       back() { return *(m_end_ - 1); }
                    ^
map.hpp:146:20: performance:inconclusive: Technically the member function 'map < char , int , bool ( * ) ( char , char ) , std :: allocator < ft :: pair < const Key , int > > >::value_comp' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    value_compare  value_comp() const { return value_compare(m_key_compare_); }
                   ^
deque.hpp:282:28: style:inconclusive: Technically the member function 'deque < int , std :: allocator < int > >::begin' can be const. [functionConst]
    iterator               begin() { return m_start_; }
                           ^
deque.hpp:284:28: style:inconclusive: Technically the member function 'deque < int , std :: allocator < int > >::end' can be const. [functionConst]
    iterator               end() { return m_finish_; }
                           ^
deque.hpp:296:28: performance:inconclusive: Technically the member function 'deque < int , std :: allocator < int > >::max_size' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    size_type              max_size() const;
                           ^
deque.hpp:522:54: note: Technically the member function 'deque < int , std :: allocator < int > >::max_size' can be static (but you may consider moving to unnamed namespace).
typename deque<T, Alloc>::size_type deque<T, Alloc>::max_size() const {
                                                     ^
deque.hpp:296:28: note: Technically the member function 'deque < int , std :: allocator < int > >::max_size' can be static (but you may consider moving to unnamed namespace).
    size_type              max_size() const;
                           ^
deque.hpp:305:28: style:inconclusive: Technically the member function 'deque < int , std :: allocator < int > >::front' can be const. [functionConst]
    reference              front() { return *m_start_; }
                           ^
deque.hpp:307:28: style:inconclusive: Technically the member function 'deque < int , std :: allocator < int > >::back' can be const. [functionConst]
    reference              back() { return *(m_finish_ - 1); }
                           ^
deque.hpp:282:28: style:inconclusive: Technically the member function 'deque < unsigned int , std :: allocator < int > >::begin' can be const. [functionConst]
    iterator               begin() { return m_start_; }
                           ^
deque.hpp:284:28: style:inconclusive: Technically the member function 'deque < unsigned int , std :: allocator < int > >::end' can be const. [functionConst]
    iterator               end() { return m_finish_; }
                           ^
deque.hpp:296:28: performance:inconclusive: Technically the member function 'deque < unsigned int , std :: allocator < int > >::max_size' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    size_type              max_size() const;
                           ^
deque.hpp:522:54: note: Technically the member function 'deque < unsigned int , std :: allocator < int > >::max_size' can be static (but you may consider moving to unnamed namespace).
typename deque<T, Alloc>::size_type deque<T, Alloc>::max_size() const {
                                                     ^
deque.hpp:296:28: note: Technically the member function 'deque < unsigned int , std :: allocator < int > >::max_size' can be static (but you may consider moving to unnamed namespace).
    size_type              max_size() const;
                           ^
deque.hpp:305:28: style:inconclusive: Technically the member function 'deque < unsigned int , std :: allocator < int > >::front' can be const. [functionConst]
    reference              front() { return *m_start_; }
                           ^
deque.hpp:307:28: style:inconclusive: Technically the member function 'deque < unsigned int , std :: allocator < int > >::back' can be const. [functionConst]
    reference              back() { return *(m_finish_ - 1); }
                           ^
type_traits.hpp:32:37: style:inconclusive: Technically the member function 'integral_constant < bool , true >::operatorT' can be const. [functionConst]
                                    operator T() { return v; }
                                    ^
tree.hpp:241:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const int , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:250:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const int , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:241:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const char , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:250:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const char , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:241:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const std :: string , char > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:250:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const std :: string , char > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:190:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const int , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:199:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const int , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:190:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const char , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:199:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const char , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:190:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std :: string , char > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:199:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std :: string , char > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:190:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std , char > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:199:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std , char > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
map.hpp:79:5: style: Class 'map < char , int , bool ( * ) ( char , char ) , std :: allocator < ft :: pair < const Key , int > > >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    map(InputIterator first, InputIterator last,
    ^
utility.hpp:32:5: style: Struct 'pair < int , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < int , char >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < std :: string , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < std :: string , double >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < ft :: map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > > :: iterator , bool >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < char , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < ft :: map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > > :: iterator , ft :: map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > > :: iterator >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < const char , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
iterator.hpp:177:5: style: Class 'reverse_iterator < ft :: vector < int , std :: allocator < int > > :: iterator >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    reverse_iterator(const reverse_iterator<Iter>& rev_it)
    ^
deque.hpp:85:5: style: Class 'deque_iterator < int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    deque_iterator(const iterator& src)
    ^
deque.hpp:85:5: style: Class 'deque_iterator < const int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    deque_iterator(const iterator& src)
    ^
deque.hpp:85:5: style: Class 'deque_iterator < unsigned int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    deque_iterator(const iterator& src)
    ^
deque.hpp:85:5: style: Class 'deque_iterator < const unsigned int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    deque_iterator(const iterator& src)
    ^
deque.hpp:507:68: style:inconclusive: Function 'operator=' argument 1 names different: declaration 'x' definition 'rhs'. [funcArgNamesDifferent]
deque<T, Alloc>& deque<T, Alloc>::operator=(const deque<T, Alloc>& rhs) {
                                                                   ^
deque.hpp:279:51: note: Function 'operator=' argument 1 names different: declaration 'x' definition 'rhs'.
    deque&                 operator=(const deque& x);
                                                  ^
deque.hpp:507:68: note: Function 'operator=' argument 1 names different: declaration 'x' definition 'rhs'.
deque<T, Alloc>& deque<T, Alloc>::operator=(const deque<T, Alloc>& rhs) {
                                                                   ^
vector.hpp:93:19: style: Local variable 'size' shadows outer function [shadowFunction]
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:88:15: note: Shadowed declaration
    size_type size() const { return static_cast<size_type>(m_end_ - m_begin_); }
              ^
vector.hpp:93:19: note: Shadow variable
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:120:19: style: Local variable 'size' shadows outer function [shadowFunction]
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:88:15: note: Shadowed declaration
    size_type size() const { return static_cast<size_type>(m_end_ - m_begin_); }
              ^
vector.hpp:120:19: note: Shadow variable
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:190:19: style: Local variable 'end' shadows outer function [shadowFunction]
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:72:28: note: Shadowed declaration
    iterator               end() { return iterator(m_end_); }
                           ^
vector.hpp:190:19: note: Shadow variable
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:211:19: style: Local variable 'end' shadows outer function [shadowFunction]
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:72:28: note: Shadowed declaration
    iterator               end() { return iterator(m_end_); }
                           ^
vector.hpp:211:19: note: Shadow variable
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:255:25: style: Local variable 'max_size' shadows outer function [shadowFunction]
        const size_type max_size = ft::vector<T>::max_size();
                        ^
vector.hpp:90:15: note: Shadowed declaration
    size_type max_size() const { return m_allocator_.max_size(); }
              ^
vector.hpp:255:25: note: Shadow variable
        const size_type max_size = ft::vector<T>::max_size();
                        ^
ori_test/main.cpp:87:27: warning: Return value of function vector_buffer.at() is not used. [ignoredReturnValue]
            vector_buffer.at(idx);
                          ^
ori_test/main.cpp:107:30: style: Variable 'copy' is assigned a value that is never used. [unreadVariable]
    { ft::map<int, int> copy = map_int; }
                             ^
iterator.hpp:177:5: style: Class 'reverse_iterator < ft :: random_access_iterator < int > >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    reverse_iterator(const reverse_iterator<Iter>& rev_it)
    ^
iterator.hpp:177:5: style: Class 'reverse_iterator < ft :: random_access_iterator < const int > >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    reverse_iterator(const reverse_iterator<Iter>& rev_it)
    ^
main.cpp:683:0: style: The function 'testAdvance' is never used. [unusedFunction]

^
main.cpp:60:0: style: The function 'testBinaryFunction' is never used. [unusedFunction]

^
main.cpp:430:0: style: The function 'testCopy' is never used. [unusedFunction]

^
main.cpp:416:0: style: The function 'testCopyBackward' is never used. [unusedFunction]

^
main.cpp:665:0: style: The function 'testDistance' is never used. [unusedFunction]

^
main.cpp:464:0: style: The function 'testEqual' is never used. [unusedFunction]

^
main.cpp:405:0: style: The function 'testFill' is never used. [unusedFunction]

^
main.cpp:701:0: style: The function 'testIteratorTraits' is never used. [unusedFunction]

^
main.cpp:48:0: style: The function 'testLess' is never used. [unusedFunction]

^
main.cpp:479:0: style: The function 'testLexicographicalCompare' is never used. [unusedFunction]

^
main.cpp:374:0: style: The function 'testMakePair' is never used. [unusedFunction]

^
main.cpp:768:0: style: The function 'testMapBegin' is never used. [unusedFunction]

^
main.cpp:938:0: style: The function 'testMapClear' is never used. [unusedFunction]

^
main.cpp:733:0: style: The function 'testMapConstructor' is never used. [unusedFunction]

^
main.cpp:1002:0: style: The function 'testMapCount' is never used. [unusedFunction]

^
main.cpp:814:0: style: The function 'testMapEmpty' is never used. [unusedFunction]

^
main.cpp:779:0: style: The function 'testMapEnd' is never used. [unusedFunction]

^
main.cpp:1040:0: style: The function 'testMapEqualRange' is never used. [unusedFunction]

^
main.cpp:894:0: style: The function 'testMapErase' is never used. [unusedFunction]

^
main.cpp:986:0: style: The function 'testMapFind' is never used. [unusedFunction]

^
main.cpp:1054:0: style: The function 'testMapGetAllocator' is never used. [unusedFunction]

^
main.cpp:863:0: style: The function 'testMapInsert' is never used. [unusedFunction]

^
main.cpp:1064:0: style: The function 'testMapIterator' is never used. [unusedFunction]

^
main.cpp:957:0: style: The function 'testMapKeyComp' is never used. [unusedFunction]

^
main.cpp:1019:0: style: The function 'testMapLowerBoundUpperBound' is never used. [unusedFunction]

^
main.cpp:837:0: style: The function 'testMapMaxSize' is never used. [unusedFunction]

^
main.cpp:850:0: style: The function 'testMapOperatorAccessElement' is never used. [unusedFunction]

^
main.cpp:754:0: style: The function 'testMapOperatorEqual' is never used. [unusedFunction]

^
main.cpp:790:0: style: The function 'testMapRbegin' is never used. [unusedFunction]

^
main.cpp:802:0: style: The function 'testMapRend' is never used. [unusedFunction]

^
main.cpp:826:0: style: The function 'testMapSize' is never used. [unusedFunction]

^
main.cpp:919:0: style: The function 'testMapSwap' is never used. [unusedFunction]

^
main.cpp:972:0: style: The function 'testMapValueComp' is never used. [unusedFunction]

^
main.cpp:437:0: style: The function 'testMax' is never used. [unusedFunction]

^
main.cpp:444:0: style: The function 'testMin' is never used. [unusedFunction]

^
main.cpp:493:0: style: The function 'testPairConstructor' is never used. [unusedFunction]

^
main.cpp:397:0: style: The function 'testPairOperatoEqual' is never used. [unusedFunction]

^
main.cpp:386:0: style: The function 'testPairRelationalOperators' is never used. [unusedFunction]

^
main.cpp:640:0: style: The function 'testReverseIteratorBase' is never used. [unusedFunction]

^
main.cpp:652:0: style: The function 'testReverseIteratorConstructor' is never used. [unusedFunction]

^
main.cpp:627:0: style: The function 'testReverseIteratorOperatorAsterisk' is never used. [unusedFunction]

^
main.cpp:584:0: style: The function 'testReverseIteratorOperatorMinus' is never used. [unusedFunction]

^
main.cpp:562:0: style: The function 'testReverseIteratorOperatorMinusEqual' is never used. [unusedFunction]

^
main.cpp:571:0: style: The function 'testReverseIteratorOperatorMinusMinus' is never used. [unusedFunction]

^
main.cpp:508:0: style: The function 'testReverseIteratorOperatorMinusNonmember' is never used. [unusedFunction]

^
main.cpp:539:0: style: The function 'testReverseIteratorOperatorOffset' is never used. [unusedFunction]

^
main.cpp:618:0: style: The function 'testReverseIteratorOperatorPlus' is never used. [unusedFunction]

^
main.cpp:593:0: style: The function 'testReverseIteratorOperatorPlusEqual' is never used. [unusedFunction]

^
main.cpp:517:0: style: The function 'testReverseIteratorOperatorPlusNonmember' is never used. [unusedFunction]

^
main.cpp:602:0: style: The function 'testReverseIteratorOperatorPlusPlus' is never used. [unusedFunction]

^
main.cpp:548:0: style: The function 'testReverseIteratorOperatorPointer' is never used. [unusedFunction]

^
main.cpp:526:0: style: The function 'testReverseIteratorRelationalOperators' is never used. [unusedFunction]

^
main.cpp:451:0: style: The function 'testSwap' is never used. [unusedFunction]

^
main.cpp:187:0: style: The function 'testVectorAssign' is never used. [unusedFunction]

^
main.cpp:221:0: style: The function 'testVectorAt' is never used. [unusedFunction]

^
main.cpp:202:0: style: The function 'testVectorBack' is never used. [unusedFunction]

^
main.cpp:341:0: style: The function 'testVectorBegin' is never used. [unusedFunction]

^
main.cpp:280:0: style: The function 'testVectorCapacity' is never used. [unusedFunction]

^
main.cpp:113:0: style: The function 'testVectorClear' is never used. [unusedFunction]

^
main.cpp:356:0: style: The function 'testVectorConstructor' is never used. [unusedFunction]

^
main.cpp:269:0: style: The function 'testVectorEmpty' is never used. [unusedFunction]

^
main.cpp:335:0: style: The function 'testVectorEnd' is never used. [unusedFunction]

^
main.cpp:141:0: style: The function 'testVectorErase' is never used. [unusedFunction]

^
main.cpp:213:0: style: The function 'testVectorFront' is never used. [unusedFunction]

^
main.cpp:100:0: style: The function 'testVectorGetAllocator' is never used. [unusedFunction]

^
main.cpp:151:0: style: The function 'testVectorInsert' is never used. [unusedFunction]

^
main.cpp:300:0: style: The function 'testVectorMaxSize' is never used. [unusedFunction]

^
main.cpp:347:0: style: The function 'testVectorOperatorEqual' is never used. [unusedFunction]

^
main.cpp:229:0: style: The function 'testVectorOperatorReference' is never used. [unusedFunction]

^
main.cpp:165:0: style: The function 'testVectorPopBack' is never used. [unusedFunction]

^
main.cpp:178:0: style: The function 'testVectorPushBack' is never used. [unusedFunction]

^
main.cpp:327:0: style: The function 'testVectorRbegin' is never used. [unusedFunction]

^
main.cpp:89:0: style: The function 'testVectorRelationalOperators' is never used. [unusedFunction]

^
main.cpp:319:0: style: The function 'testVectorRend' is never used. [unusedFunction]

^
main.cpp:244:0: style: The function 'testVectorReserve' is never used. [unusedFunction]

^
main.cpp:288:0: style: The function 'testVectorResize' is never used. [unusedFunction]

^
main.cpp:308:0: style: The function 'testVectorSize' is never used. [unusedFunction]

^
main.cpp:129:0: style: The function 'testVectorSwap' is never used. [unusedFunction]

^
main.cpp:75:0: style: The function 'testVectorSwapNonMember' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

