main.cpp:321:14: style: Redundant initialization for 'rit'. The initialized value is overwritten before it is read. [redundantInitialization]
    for (rit = v.rbegin(); rit != v.rend(); ++rit) *rit = ++i;
             ^
main.cpp:319:43: note: rit is initialized
    ft::vector<int>::reverse_iterator rit = v.rbegin();
                                          ^
main.cpp:321:14: note: rit is overwritten
    for (rit = v.rbegin(); rit != v.rend(); ++rit) *rit = ++i;
             ^
main.cpp:834:39: style: Local variable 'it' shadows outer variable [shadowVariable]
    for (ft::map<char, int>::iterator it = m.begin(); it != m.end(); ++it) {
                                      ^
main.cpp:830:34: note: Shadowed declaration
    ft::map<char, int>::iterator it;
                                 ^
main.cpp:834:39: note: Shadow variable
    for (ft::map<char, int>::iterator it = m.begin(); it != m.end(); ++it) {
                                      ^
main.cpp:839:39: style: Local variable 'it' shadows outer variable [shadowVariable]
    for (ft::map<char, int>::iterator it = m2.begin(); it != m2.end(); ++it) {
                                      ^
main.cpp:830:34: note: Shadowed declaration
    ft::map<char, int>::iterator it;
                                 ^
main.cpp:839:39: note: Shadow variable
    for (ft::map<char, int>::iterator it = m2.begin(); it != m2.end(); ++it) {
                                      ^
main.cpp:355:21: style: Unused variable: first [unusedVariable]
    ft::vector<int> first;
                    ^
main.cpp:695:17: style: Variable 'fourth['b']' is assigned a value that is never used. [unreadVariable]
    fourth['b'] = 30;
                ^
main.cpp:699:16: style: Variable 'fifth['d']' is assigned a value that is never used. [unreadVariable]
    fifth['d'] = 70;
               ^
vector.hpp:332:41: warning:inconclusive: Member variable 'vector < int , std :: allocator < int > >::m_allocator_' is not assigned a value in 'vector < int , std :: allocator < int > >::operator='. [operatorEqVarError]
vector<T, Alloc>& ft::vector<T, Alloc>::operator=(const vector& x) {
                                        ^
map.hpp:85:5: warning:inconclusive: Member variable 'map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > >::m_key_compare_' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    map(const map& x)
    ^
map.hpp:85:5: warning:inconclusive: Member variable 'map < int , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > >::m_key_compare_' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    map(const map& x)
    ^
map.hpp:85:5: warning:inconclusive: Member variable 'map < std :: string , char , ft :: less < Key > , std :: allocator < ft :: pair < const Key , char > > >::m_key_compare_' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    map(const map& x)
    ^
main.cpp:56:10: style:inconclusive: Technically the member function 'Compare::operator()' can be const. [functionConst]
    bool operator()(int a, int b) { return (a == b); }
         ^
vector.hpp:134:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::operator[]' can be const. [functionConst]
    reference       operator[](size_type n) { return *(m_begin_ + n); }
                    ^
vector.hpp:137:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::at' can be const. [functionConst]
    reference       at(size_type n) {
                    ^
vector.hpp:150:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::front' can be const. [functionConst]
    reference       front() { return *m_begin_; }
                    ^
vector.hpp:153:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::back' can be const. [functionConst]
    reference       back() { return *(m_end_ - 1); }
                    ^
type_traits.hpp:32:37: style:inconclusive: Technically the member function 'integral_constant < bool , true >::operatorT' can be const. [functionConst]
                                    operator T() { return v; }
                                    ^
map.hpp:146:20: performance:inconclusive: Technically the member function 'map < char , int , bool ( * ) ( char , char ) , std :: allocator < ft :: pair < const Key , int > > >::value_comp' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    value_compare  value_comp() const { return value_compare(m_key_compare_); }
                   ^
tree.hpp:241:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const char , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:250:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const char , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:241:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const int , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:250:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const int , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:241:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const std :: string , char > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:250:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const std :: string , char > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:190:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const char , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:199:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const char , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:190:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const int , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:199:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const int , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:190:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std :: string , char > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:199:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std :: string , char > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:190:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std , char > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:199:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std , char > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
map.hpp:79:5: style: Class 'map < char , int , bool ( * ) ( char , char ) , std :: allocator < ft :: pair < const Key , int > > >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    map(InputIterator first, InputIterator last,
    ^
utility.hpp:32:5: style: Struct 'pair < int , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < int , char >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < std :: string , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < std :: string , double >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < ft :: map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > > :: iterator , bool >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < char , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < ft :: map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > > :: iterator , ft :: map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > > :: iterator >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:32:5: style: Struct 'pair < const char , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
iterator.hpp:97:5: style: Class 'reverse_iterator < ft :: vector < int , std :: allocator < int > > :: iterator >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    reverse_iterator(const reverse_iterator<Iter>& rev_it)
    ^
vector.hpp:93:19: style: Local variable 'size' shadows outer function [shadowFunction]
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:88:15: note: Shadowed declaration
    size_type size() const { return static_cast<size_type>(m_end_ - m_begin_); }
              ^
vector.hpp:93:19: note: Shadow variable
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:120:19: style: Local variable 'size' shadows outer function [shadowFunction]
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:88:15: note: Shadowed declaration
    size_type size() const { return static_cast<size_type>(m_end_ - m_begin_); }
              ^
vector.hpp:120:19: note: Shadow variable
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:190:19: style: Local variable 'end' shadows outer function [shadowFunction]
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:72:28: note: Shadowed declaration
    iterator               end() { return iterator(m_end_); }
                           ^
vector.hpp:190:19: note: Shadow variable
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:211:19: style: Local variable 'end' shadows outer function [shadowFunction]
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:72:28: note: Shadowed declaration
    iterator               end() { return iterator(m_end_); }
                           ^
vector.hpp:211:19: note: Shadow variable
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:255:25: style: Local variable 'max_size' shadows outer function [shadowFunction]
        const size_type max_size = ft::vector<T>::max_size();
                        ^
vector.hpp:90:15: note: Shadowed declaration
    size_type max_size() const { return m_allocator_.max_size(); }
              ^
vector.hpp:255:25: note: Shadow variable
        const size_type max_size = ft::vector<T>::max_size();
                        ^
ori_test/main.cpp:87:27: warning: Return value of function vector_buffer.at() is not used. [ignoredReturnValue]
            vector_buffer.at(idx);
                          ^
ori_test/main.cpp:107:30: style: Variable 'copy' is assigned a value that is never used. [unreadVariable]
    { ft::map<int, int> copy = map_int; }
                             ^
iterator.hpp:97:5: style: Class 'reverse_iterator < ft :: random_access_iterator < int > >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    reverse_iterator(const reverse_iterator<Iter>& rev_it)
    ^
iterator.hpp:97:5: style: Class 'reverse_iterator < ft :: random_access_iterator < const int > >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    reverse_iterator(const reverse_iterator<Iter>& rev_it)
    ^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

