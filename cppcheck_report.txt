main.cpp:322:14: style: Redundant initialization for 'rit'. The initialized value is overwritten before it is read. [redundantInitialization]
    for (rit = v.rbegin(); rit != v.rend(); ++rit) *rit = ++i;
             ^
main.cpp:320:43: note: rit is initialized
    ft::vector<int>::reverse_iterator rit = v.rbegin();
                                          ^
main.cpp:322:14: note: rit is overwritten
    for (rit = v.rbegin(); rit != v.rend(); ++rit) *rit = ++i;
             ^
main.cpp:810:39: style: Local variable 'it' shadows outer variable [shadowVariable]
    for (ft::map<char, int>::iterator it = m.begin(); it != m.end(); ++it) {
                                      ^
main.cpp:806:34: note: Shadowed declaration
    ft::map<char, int>::iterator it;
                                 ^
main.cpp:810:39: note: Shadow variable
    for (ft::map<char, int>::iterator it = m.begin(); it != m.end(); ++it) {
                                      ^
main.cpp:815:39: style: Local variable 'it' shadows outer variable [shadowVariable]
    for (ft::map<char, int>::iterator it = m2.begin(); it != m2.end(); ++it) {
                                      ^
main.cpp:806:34: note: Shadowed declaration
    ft::map<char, int>::iterator it;
                                 ^
main.cpp:815:39: note: Shadow variable
    for (ft::map<char, int>::iterator it = m2.begin(); it != m2.end(); ++it) {
                                      ^
main.cpp:356:21: style: Unused variable: first [unusedVariable]
    ft::vector<int> first;
                    ^
main.cpp:671:17: style: Variable 'fourth['b']' is assigned a value that is never used. [unreadVariable]
    fourth['b'] = 30;
                ^
main.cpp:675:16: style: Variable 'fifth['d']' is assigned a value that is never used. [unreadVariable]
    fifth['d'] = 70;
               ^
vector.hpp:334:41: warning:inconclusive: Member variable 'vector < int , std :: allocator < int > >::m_allocator_' is not assigned a value in 'vector < int , std :: allocator < int > >::operator='. [operatorEqVarError]
vector<T, Alloc>& ft::vector<T, Alloc>::operator=(const vector& x) {
                                        ^
map.hpp:87:5: warning:inconclusive: Member variable 'map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > >::m_key_compare_' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    map(const map& x)
    ^
map.hpp:87:5: warning:inconclusive: Member variable 'map < int , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > >::m_key_compare_' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    map(const map& x)
    ^
map.hpp:87:5: warning:inconclusive: Member variable 'map < std :: string , char , ft :: less < Key > , std :: allocator < ft :: pair < const Key , char > > >::m_key_compare_' is not assigned in the copy constructor. Should it be copied? [uninitMemberVar]
    map(const map& x)
    ^
main.cpp:57:10: style:inconclusive: Technically the member function 'Compare::operator()' can be const. [functionConst]
    bool operator()(int a, int b) { return (a == b); }
         ^
vector.hpp:136:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::operator[]' can be const. [functionConst]
    reference       operator[](size_type n) { return *(m_begin_ + n); }
                    ^
vector.hpp:139:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::at' can be const. [functionConst]
    reference       at(size_type n) {
                    ^
vector.hpp:152:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::front' can be const. [functionConst]
    reference       front() { return *m_begin_; }
                    ^
vector.hpp:155:21: style:inconclusive: Technically the member function 'vector < int , std :: allocator < int > >::back' can be const. [functionConst]
    reference       back() { return *(m_end_ - 1); }
                    ^
type_traits.hpp:33:37: style:inconclusive: Technically the member function 'integral_constant < bool , true >::operatorT' can be const. [functionConst]
                                    operator T() { return v; }
                                    ^
map.hpp:148:20: performance:inconclusive: Technically the member function 'map < char , int , bool ( * ) ( char , char ) , std :: allocator < ft :: pair < const Key , int > > >::value_comp' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    value_compare  value_comp() const { return value_compare(m_key_compare_); }
                   ^
tree.hpp:242:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const char , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:251:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const char , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:242:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const int , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:251:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const int , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:242:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const std :: string , char > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:251:14: style:inconclusive: Technically the member function 'const_tree_iterator < ft :: pair < const std :: string , char > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:191:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const char , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:200:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const char , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:191:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const int , int > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:200:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const int , int > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:191:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std :: string , char > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:200:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std :: string , char > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
tree.hpp:191:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std , char > >::operator++' can be const. [functionConst]
    iterator operator++(int) {
             ^
tree.hpp:200:14: style:inconclusive: Technically the member function 'tree_iterator < ft :: pair < const std , char > >::operator--' can be const. [functionConst]
    iterator operator--(int) {
             ^
map.hpp:81:5: style: Class 'map < char , int , bool ( * ) ( char , char ) , std :: allocator < ft :: pair < const Key , int > > >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    map(InputIterator first, InputIterator last,
    ^
utility.hpp:33:5: style: Struct 'pair < int , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:33:5: style: Struct 'pair < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:33:5: style: Struct 'pair < int , char >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:33:5: style: Struct 'pair < std :: string , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:33:5: style: Struct 'pair < std :: string , double >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:33:5: style: Struct 'pair < ft :: map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > > :: iterator , bool >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:33:5: style: Struct 'pair < char , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:33:5: style: Struct 'pair < ft :: map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > > :: iterator , ft :: map < char , int , ft :: less < Key > , std :: allocator < ft :: pair < const Key , int > > > :: iterator >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
utility.hpp:33:5: style: Struct 'pair < const char , int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    pair(const pair<U, V>& pr) : first(pr.first), second(pr.second) {}
    ^
iterator.hpp:98:5: style: Class 'reverse_iterator < ft :: vector < int , std :: allocator < int > > :: iterator >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    reverse_iterator(const reverse_iterator<Iter>& rev_it)
    ^
vector.hpp:95:19: style: Local variable 'size' shadows outer function [shadowFunction]
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:90:15: note: Shadowed declaration
    size_type size() const { return static_cast<size_type>(m_end_ - m_begin_); }
              ^
vector.hpp:95:19: note: Shadow variable
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:122:19: style: Local variable 'size' shadows outer function [shadowFunction]
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:90:15: note: Shadowed declaration
    size_type size() const { return static_cast<size_type>(m_end_ - m_begin_); }
              ^
vector.hpp:122:19: note: Shadow variable
        size_type size = ft::vector<T>::size();
                  ^
vector.hpp:192:19: style: Local variable 'end' shadows outer function [shadowFunction]
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:74:28: note: Shadowed declaration
    iterator               end() { return iterator(m_end_); }
                           ^
vector.hpp:192:19: note: Shadow variable
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:213:19: style: Local variable 'end' shadows outer function [shadowFunction]
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:74:28: note: Shadowed declaration
    iterator               end() { return iterator(m_end_); }
                           ^
vector.hpp:213:19: note: Shadow variable
        size_type end = ft::vector<T>::end() - ft::vector<T>::begin();
                  ^
vector.hpp:257:25: style: Local variable 'max_size' shadows outer function [shadowFunction]
        const size_type max_size = ft::vector<T>::max_size();
                        ^
vector.hpp:92:15: note: Shadowed declaration
    size_type max_size() const { return m_allocator_.max_size(); }
              ^
vector.hpp:257:25: note: Shadow variable
        const size_type max_size = ft::vector<T>::max_size();
                        ^
ori_test/main.cpp:87:27: warning: Return value of function vector_buffer.at() is not used. [ignoredReturnValue]
            vector_buffer.at(idx);
                          ^
ori_test/main.cpp:107:30: style: Variable 'copy' is assigned a value that is never used. [unreadVariable]
    { ft::map<int, int> copy = map_int; }
                             ^
iterator.hpp:98:5: style: Class 'reverse_iterator < ft :: random_access_iterator < int > >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    reverse_iterator(const reverse_iterator<Iter>& rev_it)
    ^
iterator.hpp:98:5: style: Class 'reverse_iterator < ft :: random_access_iterator < const int > >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    reverse_iterator(const reverse_iterator<Iter>& rev_it)
    ^
main.cpp:59:0: style: The function 'testBinaryFunction' is never used. [unusedFunction]

^
main.cpp:404:0: style: The function 'testCopy' is never used. [unusedFunction]

^
main.cpp:438:0: style: The function 'testEqual' is never used. [unusedFunction]

^
main.cpp:639:0: style: The function 'testIteratorTraits' is never used. [unusedFunction]

^
main.cpp:47:0: style: The function 'testLess' is never used. [unusedFunction]

^
main.cpp:453:0: style: The function 'testLexicographicalCompare' is never used. [unusedFunction]

^
main.cpp:373:0: style: The function 'testMakePair' is never used. [unusedFunction]

^
main.cpp:411:0: style: The function 'testMax' is never used. [unusedFunction]

^
main.cpp:418:0: style: The function 'testMin' is never used. [unusedFunction]

^
main.cpp:467:0: style: The function 'testPairConstructor' is never used. [unusedFunction]

^
main.cpp:396:0: style: The function 'testPairOperatoEqual' is never used. [unusedFunction]

^
main.cpp:385:0: style: The function 'testPairRelationalOperators' is never used. [unusedFunction]

^
main.cpp:614:0: style: The function 'testReverseIteratorBase' is never used. [unusedFunction]

^
main.cpp:626:0: style: The function 'testReverseIteratorConstructor' is never used. [unusedFunction]

^
main.cpp:601:0: style: The function 'testReverseIteratorOperatorAsterisk' is never used. [unusedFunction]

^
main.cpp:558:0: style: The function 'testReverseIteratorOperatorMinus' is never used. [unusedFunction]

^
main.cpp:536:0: style: The function 'testReverseIteratorOperatorMinusEqual' is never used. [unusedFunction]

^
main.cpp:545:0: style: The function 'testReverseIteratorOperatorMinusMinus' is never used. [unusedFunction]

^
main.cpp:482:0: style: The function 'testReverseIteratorOperatorMinusNonmember' is never used. [unusedFunction]

^
main.cpp:513:0: style: The function 'testReverseIteratorOperatorOffset' is never used. [unusedFunction]

^
main.cpp:592:0: style: The function 'testReverseIteratorOperatorPlus' is never used. [unusedFunction]

^
main.cpp:567:0: style: The function 'testReverseIteratorOperatorPlusEqual' is never used. [unusedFunction]

^
main.cpp:491:0: style: The function 'testReverseIteratorOperatorPlusNonmember' is never used. [unusedFunction]

^
main.cpp:576:0: style: The function 'testReverseIteratorOperatorPlusPlus' is never used. [unusedFunction]

^
main.cpp:522:0: style: The function 'testReverseIteratorOperatorPointer' is never used. [unusedFunction]

^
main.cpp:500:0: style: The function 'testReverseIteratorRelationalOperators' is never used. [unusedFunction]

^
main.cpp:425:0: style: The function 'testSwap' is never used. [unusedFunction]

^
main.cpp:186:0: style: The function 'testVectorAssign' is never used. [unusedFunction]

^
main.cpp:220:0: style: The function 'testVectorAt' is never used. [unusedFunction]

^
main.cpp:201:0: style: The function 'testVectorBack' is never used. [unusedFunction]

^
main.cpp:340:0: style: The function 'testVectorBegin' is never used. [unusedFunction]

^
main.cpp:279:0: style: The function 'testVectorCapacity' is never used. [unusedFunction]

^
main.cpp:112:0: style: The function 'testVectorClear' is never used. [unusedFunction]

^
main.cpp:355:0: style: The function 'testVectorConstructor' is never used. [unusedFunction]

^
main.cpp:268:0: style: The function 'testVectorEmpty' is never used. [unusedFunction]

^
main.cpp:334:0: style: The function 'testVectorEnd' is never used. [unusedFunction]

^
main.cpp:140:0: style: The function 'testVectorErase' is never used. [unusedFunction]

^
main.cpp:212:0: style: The function 'testVectorFront' is never used. [unusedFunction]

^
main.cpp:99:0: style: The function 'testVectorGetAllocator' is never used. [unusedFunction]

^
main.cpp:150:0: style: The function 'testVectorInsert' is never used. [unusedFunction]

^
main.cpp:299:0: style: The function 'testVectorMaxSize' is never used. [unusedFunction]

^
main.cpp:346:0: style: The function 'testVectorOperatorEqual' is never used. [unusedFunction]

^
main.cpp:228:0: style: The function 'testVectorOperatorReference' is never used. [unusedFunction]

^
main.cpp:164:0: style: The function 'testVectorPopBack' is never used. [unusedFunction]

^
main.cpp:177:0: style: The function 'testVectorPushBack' is never used. [unusedFunction]

^
main.cpp:326:0: style: The function 'testVectorRbegin' is never used. [unusedFunction]

^
main.cpp:88:0: style: The function 'testVectorRelationalOperators' is never used. [unusedFunction]

^
main.cpp:318:0: style: The function 'testVectorRend' is never used. [unusedFunction]

^
main.cpp:243:0: style: The function 'testVectorReserve' is never used. [unusedFunction]

^
main.cpp:287:0: style: The function 'testVectorResize' is never used. [unusedFunction]

^
main.cpp:307:0: style: The function 'testVectorSize' is never used. [unusedFunction]

^
main.cpp:128:0: style: The function 'testVectorSwap' is never used. [unusedFunction]

^
main.cpp:74:0: style: The function 'testVectorSwapNonMember' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

